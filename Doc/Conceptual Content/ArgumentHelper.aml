<?xml version="1.0" encoding="utf-8"?>
<topic id="902c4277-af51-455e-bbdb-d9dd6433d7b3" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <section address="ArgumentHelper">
      <title>ArgumentHelper</title>
      <content>
        <para>
        	The <codeInline>ArgumentHelper</codeInline> class provides a number of methods for checking arguments. Any time an assertion fails, an <codeInline>ArgumentNullException</codeInline> or <codeInline>ArgumentException</codeInline> with an appropriate message will be thrown.
        </para>
      	<autoOutline />
      </content>
      <sections>
          <section address="AssertNotNull()">
              <title>AssertNotNull()</title>
              <content>
                  <para>
                  	The <codeInline>AssertNotNull()</codeInline> methods allow you to make sure an
                  	argument is non-<codeInline>null</codeInline>. It works for both reference and
                  	nullable types:
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass
{
	public void MyMethod(string arg1, int? arg2)
	{
		ArgumentHelper.AssertNotNull(arg1, "arg1");
		ArgumentHelper.AssertNotNull(arg2, "arg2");
	}
}]]>
                  </code>
                  <para>
                  	There is also an overload of <codeInline>AssertNotNull</codeInline> that allows you to assert that any
                  	enumerable argument is non-<codeInline>null</codeInline>, and optionally check each item in the enumeration
                  	for <codeInline>null</codeInline>:
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass
{
	public void MyMethod(IList<>string> arg)
	{
		// this will throw if arg is null, or if any item in the enumeration is null
		ArgumentHelper.AssertNotNull(arg, "arg", true);
	}
}]]>
                  </code>
              </content>
          </section>
          
          <section address="AssertGenericArgumentNotNull()">
              <title>AssertGenericArgumentNotNull()</title>
              <content>
                  <para>
                  	The <codeInline>AssertGenericArgumentNotNull()</codeInline> method can be used in the special case where you have an unconstrained generic parameter that you want to ensure is non-<codeInline>null</codeInline>. Since the developer can not know whether the generic parameter will be a reference, value, or nullable type, this method is very useful:
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass<T>
{
	public void MyMethod<T>(T arg)
	{
		// this will work regardless of type T
		ArgumentHelper.AssertGenericArgumentNotNull(arg, "arg");
	}
}]]>
                  </code>
                  <para>
                  	In the case where type <codeInline>T</codeInline> above is a reference or nullable type, the call will work exactly the same as the <codeInline>AssertNotNull()</codeInline> equivalents. In the case where <codeInline>T</codeInline> is a value type, the call will be a no-op.
                  </para>
              </content>
          </section>
          
          <section address="AssertNotNullOrEmpty()">
              <title>AssertNotNullOrEmpty()</title>
              <content>
                  <para>
                  	The <codeInline>AssertNotNullOrEmpty()</codeInline> methods can be used against <codeInline>string</codeInline>s or collections. They allow you to
                  	ensure that the argument is non-<codeInline>null</codeInline> and that it is not empty. By default, a <codeInline>string</codeInline> is considered
                  	empty if it contains no characters, but an overload allows you to trim the <codeInline>string</codeInline> first, thus ensuring that it also does not
                  	consist entirely of whitespace.
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass
{
	public void MyMethod(string arg1, string arg2, IList<int> arg3)
	{
		// this will throw if arg1 is null or "" but not if it is " "
		ArgumentHelper.AssertNotNullOrEmpty(arg1, "arg1");
		// this will throw if arg2 is null or "" or " " or any combination of whitespace
		ArgumentHelper.AssertNotNullOrEmpty(arg2, "arg2", true);
		// this will throw if arg3 is null or does not contain at least one integer
		ArgumentHelper.AssertNotNullOrEmpty(arg3, "arg3");
	}
}]]>
                  </code>
              </content>
          </section>
          
          <section address="AssertEnumMember()">
              <title>AssertEnumMember()</title>
              <content>
                  <para>
                  	The <codeInline>AssertEnumMember()</codeInline> methods allow you to check enumeration arguments for correctness. They work with both flags and non-flags enumerations. The basic usage is as follows:
                  </para>
                  <code language="C#"><![CDATA[
public enum MyEnum
{
	One,
	Two,
	Three
}

public class MyClass
{
	public void MyMethod(MyEnum arg)
	{
		// this will ensure that arg is a valid member of the MyEnum enumeration
		ArgumentHelper.AssertEnumMember(arg, "arg");
	}
}]]>
                  </code>
                  <para>
                  	This is useful because calling <codeInline>MyMethod</codeInline> like this will fail at runtime:
                  </para>
                  <code language="C#"><![CDATA[
new MyClass().MyMethod((MyEnum)3);]]>
                  </code>
                  <para>
                  	Without the call to <codeInline>AssertEnumMember()</codeInline>, <codeInline>MyMethod()</codeInline> would attempt to use the invalid value of 3.
                  </para>
                  <para>
                  	The above call to <codeInline>AssertEnumMember()</codeInline> uses <codeInline>Enum.GetValues()</codeInline> to determine the valid values for the enumeration. This may not be desirable for various reasons, including efficiency and correctness. <codeInline>Enum.GetValue()</codeInline> does have a performance penalty that may be significant in tight code loops, for example. And it might not make sense for your API to accept any value in the enumeration - you may want to only accept some values. To solve these problems, there is an overload of <codeInline>AssertEnumMember()</codeInline> that allows you to provide specific enumeration values that should be accepted:
                  </para>
                  <code language="C#"><![CDATA[
public enum MyEnum
{
	One,
	Two,
	Three
}

public class MyClass
{
	private static readonly MyEnum[] _validValues = new MyEnum[] { MyEnum.One, MyEnum.Two };
	
	public void MyMethod(MyEnum arg)
	{
		// this will ensure that arg is either MyEnum.One or MyEnum.Two
		// any other value (including MyEnum.Three) will result in an exception
		ArgumentHelper.AssertEnumMember(arg, "arg", _validValues);
	}
}]]>
                  </code>
                  <para>
                  	Using flag enumerations with these methods is also very simple and intuitive. Any valid combination of the flags you provide will pass the assertion.
                  </para>
                  <code language="C#"><![CDATA[
[Flags]
public enum MyFlags
{
	One,
	Two,
	Three
}

public class MyClass
{
	private static readonly MyFlags[] _validValues = new MyFlags[] { MyFlags.One, MyFlags.Two };
	
	public void MyMethod(MyFlags arg)
	{
		// this will throw for MyFlags.Three or (MyFlags.One | MyFlags.Three)
		// but it will work for MyFlags.One or (MyFlags.One | MyFlags.Two)
		ArgumentHelper.AssertEnumMember(arg, "arg");
	}
}]]>
                  </code>
              </content>
          </section>
          
          <section address="ExtensionMethods">
              <title>Extension Methods</title>
              <content>
                  <para>
                  	The <codeInline>Kent.Boogaart.HelperTrinity.Extensions</codeInline> namespace can be imported to make argument checking even simpler and more intuitive:
                  </para>
                  <code language="C#"><![CDATA[
using Kent.Boogaart.HelperTrinity.Extensions;

public class MyClass
{
	public void MyMethod(User arg1, string arg2)
	{
		arg1.AssertNotNull("arg1");
		arg2.AssertNotNullOrEmpty("arg2", true);
	}
}]]>
                  </code>
                  <para>
                  	All the capabilities of the <codeInline>ArgumentHelper</codeInline> class are exposed via the extension methods in the <codeInline>Kent.Boogaart.HelperTrinity.Extensions</codeInline> namespace.
                  </para>
              </content>
          </section>
      </sections>
    </section>
  </developerConceptualDocument>
</topic>