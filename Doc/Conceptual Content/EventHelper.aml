<?xml version="1.0" encoding="utf-8"?>
<topic id="f183a313-7abf-49b7-ad3c-23a4b52fe26e" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <section address="EventHelper">
      <title>EventHelper</title>
      <content>
        <para>
        	The <codeInline>EventHelper</codeInline> class provides methods for raising events in a safe and simple manner. Both generic and non-generic event delegates are supported.
        </para>
      	<autoOutline />
      </content>
      <sections>
          <section address="Raise()">
              <title>Raise()</title>
              <content>
                  <para>
                  	The <codeInline>Raise()</codeInline> methods allow you to synchronously raise an event. The usage is simple:
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass
{
	public event EventHandler MyEvent;
	
	protected virtual void OnMyEvent(EventArgs e)
	{
		EventHelper.Raise(MyEvent, this, e);
	}
}]]>
                  </code>
                  <para>
                  	The call to <codeInline>Raise()</codeInline> raises the event in a thread-safe manner. If there are no listeners, the event will not be raised. Events that leverage the generic <codeInline>EventHandler&lt;T&gt;</codeInline> delegate are also supported:
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass
{
	public event EventHandler<MyEventArgs> MyEvent;
	
	protected virtual void OnMyEvent(MyEventArgs e)
	{
		EventHelper.Raise(MyEvent, this, e);
	}
}]]>
                  </code>
              </content>
          </section>
          
          <section address="BeginRaise()">
              <title>BeginRaise()</title>
              <content>
                  <para>
                  	The <codeInline>BeginRaise()</codeInline> methods can be used to asynchronously raise an event. Its use is very similar to <codeInline>Raise()</codeInline> except that some extra parameters may be provided for callback purposes:
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass
{
	public event EventHandler MyEvent;
	
	protected virtual void OnMyEvent(EventArgs e)
	{
		EventHelper.BeginRaise(MyEvent, this, e, MyCallback, "state");
	}
	
	private void MyCallback(IAsyncResult result)
	{
		// this will display "state"
		MessageBox.Show(result.AsyncState);
	}
}]]>
                  </code>
                  <para>
                  	The callback is entirely optional. If you don't need to be notified when the event has been raised, just pass in <codeInline>null</codeInline> for the <codeInline>callback</codeInline> and <codeInline>state</codeInline> parameters:
                  </para>
                  <code language="C#"><![CDATA[
protected virtual void OnMyEvent(EventArgs e)
{
	EventHelper.BeginRaise(MyEvent, this, e, null, null);
}]]>                  
                  </code>
                  <para>
                  	Just like with <codeInline>Raise()</codeInline> methods, there are <codeInline>BeginRaise()</codeInline> overloads to support the generic <codeInline>EventHandler&lt;T&gt;</codeInline> delegate.
                  </para>
              </content>
          </section>
          
          <section address="LazyEventArgumentCreation">
              <title>Lazy Event Argument Creation</title>
              <content>
                  <para>
                  	Both the <codeInline>Raise()</codeInline> and <codeInline>BeginRaise()</codeInline> methods support overloads that take an instance of the <codeInline>CreateEventArgs&lt;T&gt;</codeInline> delegate instead of an instance of <codeInline>EventArgs</codeInline>. These overloads are intended for an esoteric use case. If all of the following is true, you should consider using these overloads when raising your event: 
					<list class="bullet">
					  <listItem><para>Your event is raised very frequently</para></listItem>
					  <listItem><para>Your event rarely has listeners</para></listItem>
					  <listItem><para>Your event data is a custom <codeInline>EventArgs</codeInline> instance</para></listItem>
					  <listItem><para>The instance of the <codeInline>CreateEventArgs&lt;T&gt;</codeInline> delegate does not need to be recreated every time you raise the event</para></listItem>
					</list>
                  </para>
                  <para>
                  	Even if all these points hold true, you should measure performance to prove that the extra complexity in your code base is warranted. For a complete example that that uses lazy event argument creation please see <link xlink:href="ad6dfea7-79fd-4205-9c2e-ff0f98840497">here</link>.
                  </para>
              </content>
          </section>
          
          <section address="ExtensionMethods">
              <title>Extension Methods</title>
              <content>
                  <para>
                  	The <codeInline>Kent.Boogaart.HelperTrinity.Extensions</codeInline> namespace can be imported to make event raising even simpler and more intuitive:
                  </para>
                  <code language="C#"><![CDATA[
using Kent.Boogaart.HelperTrinity.Extensions;

public class MyClass
{
	public event EventHandler<MyEventArgs> MyEvent;
	
	protected virtual void OnMyEvent(MyEventArgs e)
	{
		MyEvent.Raise(this, e);
	}
}]]>
                  </code>
                  <para>
                  	All the capabilities of the <codeInline>EventHelper</codeInline> class are exposed via the extension methods in the <codeInline>Kent.Boogaart.HelperTrinity.Extensions</codeInline> namespace.
                  </para>
              </content>
          </section>
      </sections>
    </section>
  </developerConceptualDocument>
</topic>