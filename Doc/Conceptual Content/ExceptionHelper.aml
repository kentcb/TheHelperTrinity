<?xml version="1.0" encoding="utf-8"?>
<topic id="c16be307-98a5-46b7-b012-11ef769e5592" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <section address="ExceptionHelper">
      <title>ExceptionHelper</title>
      <content>
        <para>
        	The <codeInline>ExceptionHelper</codeInline> class provides helper methods for raising exceptions. The main advantage to using the <codeInline>ExceptionHelper</codeInline> class is that your exception messages are centralized and easy to review for consistency and correctness. Another advantage is that your code will be cleaner and therefore clearer.
        </para>
      	<autoOutline />
      </content>
      <sections>
          <section address="SetUp">
              <title>Set Up</title>
              <content>
                  <para>
                  	The <codeInline>ExceptionHelper</codeInline> class relies on finding your exception messages in an embedded resource called <legacyItalic>ExceptionHelper.xml</legacyItalic>. The resource name used to look up this XML document is "assembly name.Properties.ExceptionHelper.xml", where the assembly is determined by the type you pass to the <codeInline>ExceptionHelper</codeInline> constructor. The easiest way to set this up in Visual Studio is:           	
<list class="ordered">
  <listItem><para>Add a new XML file called <legacyItalic>ExceptionHelper.xml</legacyItalic> to your project.</para></listItem>
  <listItem><para>View the properties of this file and change the <legacyItalic>Build Action</legacyItalic> to <legacyItalic>Embedded Resource</legacyItalic>.</para></listItem>
    <listItem><para>Drag the file under the <legacyItalic>Properties</legacyItalic> directory of your project.</para></listItem>
</list>
                  </para>
                  <para>
                  	The end result should resemble this:                  	
                  	<mediaLink>
					<image xlink:href="ExceptionHelper.xml"/>
					</mediaLink>
                  </para>
              </content>
          </section>
          
          <section address="ExceptionHelper.xmlFormat">
              <title>ExceptionHelper.xml Format</title>
              <content>
                  <para>
                  	The format of the <legacyItalic>ExceptionHelper.xml</legacyItalic> file is quite simple. For each exception that you might throw, you should include an <codeInline>&lt;exception/&gt;</codeInline> element. These elements are grouped under <codeInline>&lt;exceptionGroup*gt;</codeInline> elements according to the type that might throw the exception. Here is an example:
                  </para>
                  <code language="XML"><![CDATA[
<?xml version="1.0" encoding="utf-8" ?>

<exceptionHelper>
    <exceptionGroup type="MyNamespace.MyType, MyAssembly">
        <exception key="missing" type="System.InvalidOperationException">
            I can't find the byte array.
        </exception>

        <exception key="tooBig" type="System.InvalidOperationException">
            I found the byte array but it is too big ({0} bytes).
        </exception>
    </exceptionGroup>

    <exceptionGroup type="MyNamespace.MyOtherType, MyAssembly">
        <exception key="missing" type="MyNamespace.MyException, MyAssembly">
            I can't find the string.
        </exception>
    </exceptionGroup>
</exceptionHelper>]]>
                  </code>
                  <para>
                  	When the <codeInline>ExceptionHelper</codeInline> needs to throw an exception, it will attempt to look up the exception details in this XML document. The type you pass to the <codeInline>ExceptionHelper</codeInline> constructor is used to find the correct exception group. This means that different types can use the same exception key without clashing.
                  </para>
                  <para>
					Notice also that that the messages can include parameters, as is the case with the "tooBig" exception above. These parameters adhere to standard .NET formatting conventions.
                  </para>
              </content>
          </section>
          
          <section address="Resolve()">
              <title>Resolve()</title>
              <content>
                  <para>
                  	The <codeInline>Resolve()</codeInline> methods are used to simply resolve an exception instance so that you can subsequently throw it:
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass
{
	private static readonly ExceptionHelper _exceptionHelper = new ExceptionHelper(typeof(MyClass));
	
	public void MyMethod()
	{
		try
		{
			// dangerous call here
		}
		catch (IOException ex)
		{
			// throw a different exception that wraps the IOException
			throw _exceptionHelper.Resolve("SomeKey", ex);
		}
	}
}]]>
                  </code>
                  <para>
                  	Various overloads exist so that you can pass message arguments and additional constructor arguments.
                  </para>
              </content>
          </section>
          
          <section address="ResolveAndThrowIf()">
              <title>ResolveAndThrowIf()</title>
              <content>
                  <para>
                  	The <codeInline>ResolveAndThrowIf()</codeInline> methods will resolve and throw an exception, but only if a specified condition is true. Various overloads exist so that you can pass message parameters, pass an inner exception, and pass additional constructor arguments for the exception type. A simple example of usage is:
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass : IDisposable
{
	private static readonly ExceptionHelper _exceptionHelper = new ExceptionHelper(typeof(MyClass));
	private bool _disposed;
	
	public void Dispose()
	{
		_disposed = true;
		// other clean up code
	}
	
	public void MyMethod()
	{
		_exceptionHelper.ResolveAndThrowIf(_disposed, "ObjectDisposed");
		// other logic
	}
}]]>
                  </code>
                  <para>
					In this example, <codeInline>MyMethod()</codeInline> will throw an exception if the object has already been disposed. The exception group might be declared in the <legacyItalic>ExceptionHelper.xml</legacyItalic> file like this:
                  </para>
                  <code language="XML"><![CDATA[
<exceptionGroup type="MyClass, MyAssembly">
	<exception key="ObjectDisposed" type="System.ObjectDisposedException">
		Cannot access a disposed instance of MyClass.
	</exception>
</exceptionGroup>]]>
                  </code>
                  <para>
                  	A more complicated example of using <codeInline>ResolveAndThrowIf()</codeInline> is:
                  </para>
                  <code language="C#"><![CDATA[
public class MyClass
{
	private static readonly ExceptionHelper _exceptionHelper = new ExceptionHelper(typeof(MyClass));
	private const int _minLength = 3;
	private const int _maxLength = 6;
	
	public void MyMethod(string userName)
	{
		ArgumentHelper.AssertNotNull(userName, "userName");
		_exceptionHelper.ResolveAndThrowIf(
                     userName.Length < _minLength || userName.Length > _maxLength,
                     "InvalidUserName",
                     userName,
                     _minLength,
                     _maxLength);

		// other logic
	}
}]]>
                  </code>
                  <para>
                  	The corresponding <legacyItalic>ExceptionHelper.xml</legacyItalic> might look like this:
                  </para>
                  <code language="XML"><![CDATA[
<exceptionGroup type="MyClass, MyAssembly">
	<exception key="InvalidUserName" type="System.ArgumentException">
		User name '{0}' is not between {1} and {2} characters long.
	</exception>
</exceptionGroup>]]>
                  </code>
              </content>
          </section>
      </sections>
    </section>
  </developerConceptualDocument>
</topic>